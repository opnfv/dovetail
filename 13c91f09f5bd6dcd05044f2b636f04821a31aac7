{
  "comments": [
    {
      "key": {
        "uuid": "5a3f45e8_3c789b2a",
        "filename": "dovetail/testcase.py",
        "patchSetId": 2
      },
      "lineNbr": 292,
      "author": {
        "id": 5469
      },
      "writtenOn": "2018-04-08T08:35:18Z",
      "side": 1,
      "message": "This can be self.type directly.",
      "range": {
        "startLine": 292,
        "startChar": 26,
        "endLine": 292,
        "endChar": 35
      },
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a3f45e8_f0ebf7ad",
        "filename": "dovetail/testcase.py",
        "patchSetId": 2
      },
      "lineNbr": 292,
      "author": {
        "id": 585
      },
      "writtenOn": "2018-04-09T07:51:24Z",
      "side": 1,
      "message": "Hi Xudan. I believe self.type is not a correct syntax for a method parameter. I need to use a parameter here in order to overwrite the base method. Or, maybe I don\u0027t understand what you are referring to.",
      "parentUuid": "5a3f45e8_3c789b2a",
      "range": {
        "startLine": 292,
        "startChar": 26,
        "endLine": 292,
        "endChar": 35
      },
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a3f45e8_d04b5b85",
        "filename": "dovetail/testcase.py",
        "patchSetId": 2
      },
      "lineNbr": 292,
      "author": {
        "id": 5469
      },
      "writtenOn": "2018-04-09T09:07:06Z",
      "side": 1,
      "message": "Yes, you are right. I misunderstood that.",
      "parentUuid": "5a3f45e8_f0ebf7ad",
      "range": {
        "startLine": 292,
        "startChar": 26,
        "endLine": 292,
        "endChar": 35
      },
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a3f45e8_e9d5ceb9",
        "filename": "etc/patches/functest/disable-api-validation/apply.sh",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 2651
      },
      "writtenOn": "2018-04-10T01:26:43Z",
      "side": 1,
      "message": "how about moving apply.sh to patches/apply.sh, and transfer functest/disable-api-validation/0001-Allow-additional-properties-in-API-responses.patch as the parameter, by doing so, all the patches can be patched leveraging apply.sh",
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a3f45e8_babb06e4",
        "filename": "etc/patches/functest/disable-api-validation/apply.sh",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 585
      },
      "writtenOn": "2018-04-10T18:38:28Z",
      "side": 1,
      "message": "In general a good suggestion. One aspect to consider here is that this particular patch should only be applied if a certain command line parameter is given. If apply.sh applies multiple patches (luckily we currently only have one patch), we would have to have some logic for conditionally applying a patch in apply.sh as well - even if it is just a parameter and an if-statement.\n\nApart from that, I very much agree that for generally applied patches (as for the old yardstick patch), we should have a common script/hook mechanism. As we currently only have this one patch, shall we revisit this once other (kind of) patches become necessary?",
      "parentUuid": "5a3f45e8_e9d5ceb9",
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a3f45e8_9ac0cae1",
        "filename": "etc/patches/functest/disable-api-validation/apply.sh",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 2651
      },
      "writtenOn": "2018-04-11T02:11:19Z",
      "side": 1,
      "message": "Yes, I agree to revisit this once other patches become necessary. following is an initial concept for future improvement.\n\nIMBP, patchwork is quite testcase-oriented, it should be declared in the prepare stage in testcase definition yaml file, which is tempest.tc00x.yml in our case, if it is well defined and processed, this will not be a problem, for example\n\nprepare:\n    - cd $dest_repo1/; $patch_dir/apply.sh $patch_dir/patch_file1\n    - cd $dest_repo1/; $patch_dir/apply.sh $patch_dir/patch_file2\n    - cd $dest_repo2/; $patch_dir/apply.sh $patch_dir/patch_file3\n\nAnd I tried to find a way to handle the patchwork by python, I find https://github.com/gitpython-developers/GitPython, unfortunately, git.am is not implemented, :(",
      "parentUuid": "5a3f45e8_babb06e4",
      "revId": "13c91f09f5bd6dcd05044f2b636f04821a31aac7",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    }
  ]
}